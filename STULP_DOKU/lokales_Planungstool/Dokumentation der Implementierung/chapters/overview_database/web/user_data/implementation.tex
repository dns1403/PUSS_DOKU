\subsubsection{Implementing the interface}
The main interface for the User database is the
\href{https://git.cs.upb.de/stulp.imt/database/blob/master/src/main/java/de/upb/stulp/database/webService/userData/UserDatabase.java}{UserDatabase}.
To implement this main interface simply do the following and implement
the methods you need to overwrite:

\begin{lstlisting}[language=Java]
public class MyUserDatabase implements UserDatabase {
...
}
\end{lstlisting}

An instance of this class will then be used in the Web Service to query
the database. Keep in mind that you also need to adjust the Web Service
to use your custom class.

When implementing MyUserDatabase you will notice that you also have to
return an instance of a class implementing the
\href{https://git.cs.upb.de/stulp.imt/database/blob/master/src/main/java/de/upb/stulp/database/webService/userData/UserDataRecordFactory.java}{UserDataRecordFactory}
interface as this is the only option for users of your interface to
create objects relating to tables of the database. This is needed
because the user uses these objects to pass filter information to the
queries. Thus, you will need to create the following class:

\begin{lstlisting}[language=Java]
public class MyUserDataRecordFactory 
					implements UserDataRecordFactory {
...
}
\end{lstlisting}

You will also notice that the database interface only offers one insert,
update, delete and getRecords operation, yet there can be different
tables in your database. This is due to the fact that these methods
simply delegate the operation to the different table implementations. To
take advantage of this the
\href{https://git.cs.upb.de/stulp.imt/database/blob/master/src/main/java/de/upb/stulp/database/Record.java}{Record}
interface has been introduced. This interface enables you to simply call
the corresponding method of the record interface for delegation.


\subsubsection{How are Records of database relations implemented in the interface}

Every relation in your database has a corresponding entity class that
stores exactly one record of a relation, e.g.~
\href{https://git.cs.upb.de/stulp.imt/database/blob/master/src/main/java/de/upb/stulp/database/webService/userData/User.java}{User}.
Thus, when querying the database, you wrap every record into its
corresponding interface class and return this.


\subsubsection{How to implement a record class}

To implement a record class, you simply inherit from the corresponding
interface class and override the missing methods. For example:

\begin{lstlisting}[language=Java]
public class MyUser extends User {
/*
 * make sure to make the constructors protected 
 * such that the user is forced to use the 
 * RecordFactory for instantiation
 */
...
}
\end{lstlisting}

The interface will force you to implement how such a record should be
inserted, updated, deleted and retrieved from the database. However, it
will not force you to implement the creation of a possibly necessary
table since different databases use different concepts. Keep that in
mind and consult your database manual to see what you need. You also
need to overwrite the factory methods in MyUserDataRecordFactory to be
able to instantiate your class from outside this package.

\subsubsection{How to extend the database interface}

There are two ways of extending the database interface that are quite
different in implementation effort. 1. You need to provide new
functionality that is not yet covered by the interface but the database
schema has not changed. 2. You need to change the database schema.

\subsubsection{Add new functionality without database schema change}

In order to add new functionality to the database that does not need a
schema change, you only need to add the required method to the
\href{https://git.cs.upb.de/stulp.imt/database/blob/master/src/main/java/de/upb/stulp/database/webService/userData/UserDatabase.java}{UserDatabase}
interface and add the implementation of this method to MyUserDatabase.

\subsubsection{Change the schema}

When changing the schema you have to differentiate between updating
already existent relations and adding new relations.

When updating existent relations you only need to update the interface
class that implements the Record interface, e.g.~User, and your
implementation, e.g.~MyUser, depending on what you need to change. When
using the
\href{https://git.cs.upb.de/stulp.imt/database/blob/master/src/main/java/de/upb/stulp/database/impl/webService/userData/SQLiteUser.java}{SQLiteUser}
implementation that is provided in this repository, you will also need
to update the
\href{https://git.cs.upb.de/stulp.imt/database/blob/master/src/test/resources/server_user_schema.db}{server\_user\_schema.db}
as this implementation is using JOOQ and uses automatic code generation
to create the corresponding classes to enable type safe SQL queries.

When adding a new relation to the database you need to create the
following two classes that represent a record of the new relation:

\begin{lstlisting}[language=Java]
public abstract class NewRelation implements Record {
//private nullable field for every field of the relation. 
//protected constructors
//getter and setter
//overwrite equals and hashCode methods
}
\end{lstlisting}

\begin{lstlisting}[language=Java]
public class MyNewRelation extends NewRelation {
//implement methods
}
\end{lstlisting}

After creating these classes, you need to add the factory methods for
the relation records to
\href{https://git.cs.upb.de/stulp.imt/database/blob/master/src/main/java/de/upb/stulp/database/webService/userData/UserDataRecordFactory.java}{UserDataRecordFactory}.
This will look like this:

\begin{lstlisting}[language=Java]
public interface UserDataRecordFactory {
//place holder for old interface methods
NewRelation createNewRelation();
NewRelation createNewRelation(/*list of all fields to set*/);
}
\end{lstlisting}
